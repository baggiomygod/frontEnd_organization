# event loop 事件循环

## 事件轮询，js实现异步的具体解决方案
- 同步代码，直接执行 
- 异步函数先放在异步队列中， task queue
- 待同步函数执行完毕，轮询执行异步队列的函数

```
setTimeout(() => console.log(1), 100) // 不立刻放入异步队列，告诉计算机100ms之后，再放入异步队列
setTimeout(() => console.log(2))，// 立刻放入异步队列
console.log(3) // 立即执行
setTimeout(() => console.log(4), 20) // 2打印后 20ms加入到异步队列中

3
2
4
1
```

## 异步代码被放入异步队列的情况
1. 立即放入: setTimeout(cb)
2. 一段时间都放入： setTimeout(cb, 200)
3. ajax反正成功后放入, ajax(..., success: cb)

## 轮询过程
1. 所有同步任务都在主线程上执行，形成一个执行栈execution context stack
2. 主线程之外，还存在一个任务队列（task queue）.只要异步任务有了运行结果，就在任务队列中放置一个事件
3. 一旦“主线程”中的所有同步任务执行完毕，系统就会读取“task queue”，看看里面有哪些事件。那写被放入task queue的任务结束等待，进入执行栈，开始执行
4. 主线程不断重复“3“的步骤

task queue是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程读取的过程基本上是自动的。只要执行栈一清空。task queue上的第一个事件就自动进入主线程。

但是，由于存在”定时器“功能，主线程首先要检查下执行事件，某些事件只有到了规定时间，才能回到主线程

